#!/usr/bin/env python3
"""
Validate 404 Not Found entries from a broken links report.

This utility reads a text report generated by the broken links finder, re-checks
all links that were previously reported as returning "404 Not Found", and writes
an updated validation report with the refreshed status of each link.
"""

from __future__ import annotations

import argparse
import os
import sys
import time
from datetime import datetime, timezone
from http import HTTPStatus
from typing import Any, Dict, Iterable, List, Optional, Tuple

import requests


DEFAULT_USER_AGENT = "Mozilla/5.0 (compatible; BrokenLinksValidator/1.0)"


def parse_report(file_path: str) -> Tuple[List[str], List[Dict[str, Any]]]:
    """
    Parse a plain-text broken links report into header lines and entry metadata.

    Returns a tuple of (header_lines, entries). Header lines are emitted without
    trailing newline characters. Each entry dict contains the captured fields:
    - broken_link (str)
    - status (str)
    - found_on (str, optional)
    - depth (int or str, optional)
    - timestamp (str, optional)
    - extra (List[str], optional) for any additional lines within the block
    """
    header: List[str] = []
    entries: List[Dict[str, Any]] = []
    current: Optional[Dict[str, Any]] = None
    in_entries = False

    with open(file_path, "r", encoding="utf-8") as handle:
        for raw_line in handle:
            line = raw_line.rstrip("\n")

            if line.startswith("Broken Link: "):
                in_entries = True
                if current:
                    entries.append(current)
                current = {"broken_link": line[len("Broken Link: ") :].strip()}
                continue

            if current is None:
                if not in_entries:
                    header.append(line)
                continue

            if line.startswith("Status: "):
                current["status"] = line[len("Status: ") :].strip()
            elif line.startswith("Found On: "):
                current["found_on"] = line[len("Found On: ") :].strip()
            elif line.startswith("Depth: "):
                depth_value = line[len("Depth: ") :].strip()
                try:
                    current["depth"] = int(depth_value)
                except ValueError:
                    current["depth"] = depth_value
            elif line.startswith("Timestamp: "):
                current["timestamp"] = line[len("Timestamp: ") :].strip()
            elif line.startswith("---"):
                # separator between entries; nothing to record
                continue
            elif line.strip():
                current.setdefault("extra", []).append(line)

        if current:
            entries.append(current)

    return header, entries


def format_status_text(status_code: Optional[int], reason: Optional[str]) -> str:
    """Return a human-friendly status string for the validation results."""
    if status_code is None:
        return "Request Failed"

    phrase = (reason or "").strip()
    if not phrase:
        try:
            phrase = HTTPStatus(status_code).phrase
        except ValueError:
            phrase = ""

    if phrase:
        return f"{status_code} {phrase}"

    return str(status_code)


def perform_request(
    session: requests.Session, url: str, timeout: float
) -> Tuple[Optional[int], Optional[str], Optional[str]]:
    """
    Issue HTTP requests to determine the current status of a URL.

    Returns a tuple (status_code, reason, method_used).
    - status_code can be None when the request fails entirely.
    - reason contains the response reason phrase when available.
    - method_used indicates which HTTP method produced the result.
    """
    try:
        head_response = session.head(url, allow_redirects=True, timeout=timeout)
    except requests.RequestException:
        head_response = None

    if head_response is not None:
        if head_response.status_code in (405, 501):
            head_response = None  # Force GET fallback when HEAD not allowed
        elif head_response.status_code != 404 and head_response.status_code < 400:
            return head_response.status_code, head_response.reason, "HEAD"

    # Perform GET either to confirm the 404 or because HEAD failed
    try:
        get_response = session.get(url, allow_redirects=True, timeout=timeout)
        return get_response.status_code, get_response.reason, "GET"
    except requests.RequestException as exc:
        if head_response is not None:
            return head_response.status_code, head_response.reason, "HEAD"
        return None, str(exc), "GET"


def determine_outcome(status_code: Optional[int]) -> str:
    """
    Map an HTTP status (or failure) to a validation outcome string.

    Possible return values:
    - "still_broken": 404 confirmed
    - "resolved": status < 400 and not 404
    - "other_error": status >= 400 but not 404
    - "error": network/processing failure
    """
    if status_code is None:
        return "error"
    if status_code == 404:
        return "still_broken"
    if 200 <= status_code < 400:
        return "resolved"
    return "other_error"


def validate_entries(
    entries: Iterable[Dict[str, Any]],
    session: requests.Session,
    timeout: float,
    delay: float,
    verbose: bool = False,
) -> Tuple[List[Dict[str, Any]], Dict[str, Any]]:
    """
    Re-check all entries that were previously flagged as 404.

    Returns a tuple of (validated_entries, summary) where:
    - validated_entries mirrors the input entries but contains a new "validation"
      key with detailed results.
    - summary is a dict with aggregated counts for reporting.
    """
    entries_list = list(entries)
    validated: List[Dict[str, Any]] = []
    summary = {
        "total_entries": 0,
        "rechecked": 0,
        "still_broken": 0,
        "resolved": 0,
        "other_error": 0,
        "errors": 0,
    }

    status_prefix = "404"
    total_to_recheck = sum(
        1
        for entry in entries_list
        if isinstance(entry.get("status", ""), str)
        and entry["status"].strip().startswith(status_prefix)
    )
    rechecked_so_far = 0

    for entry in entries_list:
        summary["total_entries"] += 1
        status_text = entry.get("status", "")
        validation: Dict[str, Any] = {}

        if isinstance(status_text, str) and status_text.strip().startswith(status_prefix):
            summary["rechecked"] += 1
            rechecked_so_far += 1
            if verbose:
                total_display = total_to_recheck or summary["rechecked"]
                print(
                    f"[{rechecked_so_far}/{total_display}] Rechecking {entry['broken_link']}",
                    flush=True,
                )
            status_code, reason, method_used = perform_request(
                session, entry["broken_link"], timeout
            )
            outcome = determine_outcome(status_code)
            validation_timestamp = datetime.now(timezone.utc).isoformat()

            validation.update(
                {
                    "checked": True,
                    "status_code": status_code,
                    "status_text": format_status_text(status_code, reason),
                    "method": method_used,
                    "timestamp": validation_timestamp,
                    "outcome": outcome,
                }
            )

            if status_code is None:
                validation["error"] = reason
                summary["errors"] += 1
            else:
                summary[outcome] += 1

            if delay > 0:
                time.sleep(delay)
        else:
            validation.update(
                {
                    "checked": False,
                    "status_code": None,
                    "status_text": status_text or "Unknown",
                    "method": None,
                    "timestamp": None,
                    "outcome": "skipped",
                }
            )

        enriched_entry = dict(entry)
        enriched_entry["validation"] = validation
        validated.append(enriched_entry)

    if verbose:
        print(
            "Validation complete: "
            f"{summary['resolved']} resolved, "
            f"{summary['still_broken']} still broken, "
            f"{summary['other_error']} other HTTP errors, "
            f"{summary['errors']} validation errors.",
            flush=True,
        )

    return validated, summary


def write_validated_report(
    output_path: str,
    header_lines: List[str],
    validated_entries: List[Dict[str, Any]],
    summary: Dict[str, Any],
) -> None:
    """Persist the validation results to a text file."""
    lines: List[str] = []

    if header_lines:
        lines.extend(header_lines)

    if lines and lines[-1] != "":
        lines.append("")

    lines.extend(
        [
            "Validation Summary",
            f"Validated At: {summary['validated_at']}",
            f"Source Report: {summary['source_report']}",
            f"Total Entries: {summary['total_entries']}",
            f"Links Rechecked: {summary['rechecked']}",
            f"Still Broken: {summary['still_broken']}",
            f"Resolved: {summary['resolved']}",
            f"Other HTTP Errors: {summary['other_error']}",
            f"Validation Errors: {summary['errors']}",
            "--------------------------------------------------",
        ]
    )

    # Retain only entries that remain broken after validation
    still_broken_entries = [
        entry
        for entry in validated_entries
        if (entry.get("validation") or {}).get("outcome") == "still_broken"
    ]

    for entry in still_broken_entries:
        lines.append(f"Broken Link: {entry.get('broken_link', 'Unknown')}")
        lines.append(f"Original Status: {entry.get('status', 'Unknown')}")

        if entry.get("found_on"):
            lines.append(f"Found On: {entry['found_on']}")
        if entry.get("depth") is not None:
            lines.append(f"Depth: {entry['depth']}")
        if entry.get("timestamp"):
            lines.append(f"First Seen: {entry['timestamp']}")

        validation = entry.get("validation", {})
        outcome = validation.get("outcome", "unknown").replace("_", " ").title()
        lines.append(f"Validation Outcome: {outcome}")

        status_text = validation.get("status_text")
        if status_text:
            lines.append(f"Validation Status: {status_text}")

        method = validation.get("method")
        if method:
            lines.append(f"Validation Method: {method}")

        validation_timestamp = validation.get("timestamp")
        if validation_timestamp:
            lines.append(f"Validation Checked: {validation_timestamp}")

        error_text = validation.get("error")
        if error_text:
            lines.append(f"Validation Error: {error_text}")

        for extra_line in entry.get("extra", []) or []:
            lines.append(extra_line)

        lines.append("------------------------------")

    if not still_broken_entries:
        lines.append("No links remain broken after validation.")

    with open(output_path, "w", encoding="utf-8") as handle:
        handle.write("\n".join(lines).rstrip() + "\n")


def build_default_output_path(input_path: str) -> str:
    """Create a default output path alongside the input file."""
    directory, filename = os.path.split(os.path.abspath(input_path))
    base, ext = os.path.splitext(filename)
    suffix = "_validated"
    return os.path.join(directory, f"{base}{suffix}{ext or '.txt'}")


def parse_arguments(argv: Optional[List[str]] = None) -> argparse.Namespace:
    """Parse command-line arguments for the validation script."""
    parser = argparse.ArgumentParser(
        description="Re-check 404 links in a broken links report and generate a validated report."
    )
    parser.add_argument("input", help="Path to the broken links report to validate.")
    parser.add_argument(
        "-o",
        "--output",
        help="Where to write the validated report. Defaults to <input>_validated.txt.",
    )
    parser.add_argument(
        "--timeout",
        type=float,
        default=10.0,
        help="HTTP request timeout in seconds (default: 10).",
    )
    parser.add_argument(
        "--delay",
        type=float,
        default=0.0,
        help="Delay in seconds between validation requests (default: 0).",
    )
    parser.add_argument(
        "--user-agent",
        default=DEFAULT_USER_AGENT,
        help=f"Custom User-Agent header (default: {DEFAULT_USER_AGENT}).",
    )
    parser.add_argument(
        "-v",
        "--verbose",
        action="store_true",
        help="Enable verbose output to show validation progress.",
    )

    return parser.parse_args(argv)


def main(argv: Optional[List[str]] = None) -> int:
    """CLI entry point."""
    args = parse_arguments(argv)

    if not os.path.exists(args.input):
        print(f"Input report not found: {args.input}", file=sys.stderr)
        return 1

    header_lines, entries = parse_report(args.input)

    if not entries:
        print("No broken link entries found in the report.", file=sys.stderr)
        return 1

    session = requests.Session()
    session.headers.update({"User-Agent": args.user_agent})

    validated_entries, summary = validate_entries(
        entries,
        session,
        args.timeout,
        args.delay,
        verbose=args.verbose,
    )

    summary["validated_at"] = datetime.now(timezone.utc).isoformat()
    summary["source_report"] = os.path.abspath(args.input)

    output_path = args.output or build_default_output_path(args.input)
    write_validated_report(output_path, header_lines, validated_entries, summary)

    print(f"Validated report written to {output_path}")
    return 0


if __name__ == "__main__":  # pragma: no cover - CLI invocation guard
    sys.exit(main())
